[数据库锁机制](http://blog.sina.com.cn/s/blog_548bd2090100ir7k.html)
##### 数据库锁
    数据库是一个多用户使用的共享资源。当多个用户并发地存取数据时，在数据库中就会产生多个事务同时存取同一数据的情况。若对并发操作不加控制就可能会读取和存储不正确的数据，破坏数据库的一致性。

    加锁是实现数据库并发控制的一个非常重要的技术。当事务在对某个数据对象进行操作前，先向系统发出请求，对其加锁。加锁后事务就对该数据对象有了一定的控制，在该事务释放锁之前，其他的事务不能对此数据对象进行更新操作。
    
##### 【基本锁类型】
锁包括**行级锁**和**表级锁**

- **行级锁**是一种排他锁，防止其他事务修改此行；

    - 在使用以下语句时，Oracle会自动应用行级锁：
INSERT、UPDATE、DELETE、SELECT … FOR UPDATE [OF columns] [WAIT n | NOWAIT];
    - SELECT … FOR UPDATE语句允许用户一次锁定多条记录进行更新
    - 使用COMMIT或ROLLBACK语句释放锁

- **表级锁**又分为5类：
    - 行共享 (ROW SHARE) – 禁止排他锁定表
    - 行排他(ROW EXCLUSIVE) – 禁止使用排他锁和共享锁
    - 共享锁(SHARE) - 锁定表，对记录只读不写，多个用户可以同时在同一个表上应用此锁
    - 共享行排他(SHARE ROW EXCLUSIVE) – 比共享锁更多的限制，禁止使用共享锁及更高的锁
    - 排他(EXCLUSIVE) – 限制最强的表锁，仅允许其他用户查询该表的行。禁止修改和锁定表

##### 【乐观锁与悲观锁】 
- **悲观锁**：就是基于数据库机制实现的。比如在在使用select子句的时候加上for update，那么直到改子句的事务结束为止，任何应用都无法修改select出来的记录。

- **乐观锁**：是基于应用的版本机制来实现的。一般会在表里面设计一个版本字段v（我一般会把这个字段设为timestamp）。一般的update场景是这样：
```
1 select a, v from tb where id=1;   
// 假设得到数据是：['xxx', 11111]

2 update tb set a='yyyy', v=systimestamp where v=11111; // 注意, v一般不会在业务操作的时候修改
// 这要求每一次update操作都变更版本字段,否则还是要进程间的数据 还是会被相互覆盖。
```


